<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Gesture Controlled 3D Particles</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #050505;
        color: white;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      }
      canvas {
        display: block;
      }
      #video-input {
        transform: scaleX(-1);
        display: none;
      } /* Mirror video, hide it */

      .glass-panel {
        background: rgba(20, 20, 30, 0.7);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      /* Custom scrollbar for color picker if needed */
      ::-webkit-scrollbar {
        width: 6px;
      }
      ::-webkit-scrollbar-track {
        background: transparent;
      }
      ::-webkit-scrollbar-thumb {
        background: #444;
        border-radius: 3px;
      }

      .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #000;
        z-index: 50;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        transition: opacity 0.5s;
      }

      .spinner {
        width: 50px;
        height: 50px;
        border: 3px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: #fff;
        animation: spin 1s ease-in-out infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      /* Color swatch active state */
      .color-swatch.active {
        border-color: white;
        transform: scale(1.1);
      }

      /* Shape btn active state */
      .shape-btn.active {
        background-color: rgba(255, 255, 255, 0.2);
        border-color: white;
      }
    </style>
  </head>
  <body>
    <!-- Loading Screen -->
    <div id="loading" class="loading-overlay">
      <div class="spinner mb-4"></div>
      <h2 class="text-xl font-light tracking-widest">INITIALIZING VISION</h2>
      <p class="text-gray-500 text-sm mt-2">Please allow camera access</p>
    </div>

    <!-- Hidden Video Input for MediaPipe -->
    <video id="video-input"></video>

    <!-- UI Overlay -->
    <div class="absolute top-0 left-0 w-full h-full pointer-events-none p-4 flex flex-col justify-between z-10">
      <!-- Header / Status -->
      <div class="flex justify-between items-start">
        <div class="glass-panel p-4 rounded-xl pointer-events-auto">
          <h1 class="text-lg font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-purple-500">AETHER PARTICLES</h1>
          <div class="mt-2 text-xs text-gray-300 space-y-1">
            <div class="flex items-center"><span class="w-2 h-2 rounded-full bg-green-500 mr-2" id="status-dot"></span> <span id="status-text">Waiting for camera...</span></div>
            <div>‚úã <span class="opacity-70">Distance:</span> Spread</div>
            <div>üëÜ <span class="opacity-70">Position:</span> Rotate</div>
            <div>ü§è <span class="opacity-70">Pinch:</span> Scale</div>
          </div>
        </div>

        <!-- Webcam Preview (Small) -->
        <div class="glass-panel p-1 rounded-lg pointer-events-auto w-32 h-24 relative overflow-hidden">
          <canvas id="camera-feed" class="w-full h-full object-cover transform -scale-x-100"></canvas>
          <div class="absolute bottom-1 right-1 text-[10px] bg-black/50 px-1 rounded">DEBUG</div>
        </div>
      </div>

      <!-- Controls -->
      <div class="flex flex-col md:flex-row gap-4 items-end md:items-end md:justify-center w-full pointer-events-auto pb-4">
        <!-- Shape Selector -->
        <div class="glass-panel p-3 rounded-xl flex gap-2">
          <button onclick="setShape('sphere')" class="shape-btn active p-2 rounded-lg border border-transparent hover:bg-white/10 transition">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
          </button>
          <button onclick="setShape('heart')" class="shape-btn p-2 rounded-lg border border-transparent hover:bg-white/10 transition">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"></path></svg>
          </button>
          <button onclick="setShape('saturn')" class="shape-btn p-2 rounded-lg border border-transparent hover:bg-white/10 transition">
            <!-- Simple Saturn Icon -->
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10z"></path>
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2 12s3-6 10-6 10 6 10 6-3 6-10 6-10-6-10-6z"></path>
            </svg>
          </button>
          <button onclick="setShape('flower')" class="shape-btn p-2 rounded-lg border border-transparent hover:bg-white/10 transition">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v1m6 11h2m-6 0h-2v4m0-11v3m0 0h.01M12 12h4.01M16 20h4M4 12h4m12 0h.01M5 8h2a1 1 0 001-1V5a1 1 0 00-1-1H5a1 1 0 00-1 1v2a1 1 0 001 1zm12 0h2a1 1 0 001-1V5a1 1 0 00-1-1h-2a1 1 0 00-1 1v2a1 1 0 001 1zM5 20h2a1 1 0 001-1v-2a1 1 0 00-1-1H5a1 1 0 00-1 1v2a1 1 0 001 1z"></path></svg>
          </button>
        </div>

        <!-- Color Selector -->
        <div class="glass-panel p-3 rounded-xl flex items-center gap-3">
          <div class="flex gap-2">
            <button onclick="setColor('#ef4444')" class="color-swatch w-6 h-6 rounded-full bg-red-500 border-2 border-transparent transition"></button>
            <button onclick="setColor('#3b82f6')" class="color-swatch w-6 h-6 rounded-full bg-blue-500 border-2 border-transparent transition"></button>
            <button onclick="setColor('#10b981')" class="color-swatch active w-6 h-6 rounded-full bg-green-500 border-2 border-transparent transition"></button>
            <button onclick="setColor('#f59e0b')" class="color-swatch w-6 h-6 rounded-full bg-yellow-500 border-2 border-transparent transition"></button>
            <button onclick="setColor('#ec4899')" class="color-swatch w-6 h-6 rounded-full bg-pink-500 border-2 border-transparent transition"></button>
          </div>
          <div class="w-px h-6 bg-gray-600"></div>
          <input type="color" id="customColor" class="w-8 h-8 rounded cursor-pointer bg-transparent border-none p-0" onchange="setColor(this.value)" />
        </div>
      </div>
    </div>

    <script>
      // --- Configuration ---
      const PARTICLE_COUNT = 15000;
      const PARTICLE_SIZE = 0.05;
      let currentShape = "sphere";
      let targetColor = new THREE.Color("#10b981");

      // --- State ---
      let handState = {
        present: false,
        x: 0.5,
        y: 0.5,
        pinchDistance: 1.0, // 0 to 1+
        handSize: 0.2, // Used for depth/spread
      };

      // --- Three.js Setup ---
      const scene = new THREE.Scene();
      // Fog for depth
      scene.fog = new THREE.FogExp2(0x050505, 0.03);

      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
      camera.position.z = 5;

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      document.body.appendChild(renderer.domElement);

      // --- Particles ---
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(PARTICLE_COUNT * 3);
      const targetPositions = new Float32Array(PARTICLE_COUNT * 3);

      // Initialize randomly
      for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
        positions[i] = (Math.random() - 0.5) * 10;
        targetPositions[i] = positions[i];
      }

      geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));

      // Create texture for particle
      const getTexture = () => {
        const canvas = document.createElement("canvas");
        canvas.width = 32;
        canvas.height = 32;
        const context = canvas.getContext("2d");
        const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
        gradient.addColorStop(0, "rgba(255,255,255,1)");
        gradient.addColorStop(0.2, "rgba(255,255,255,0.8)");
        gradient.addColorStop(0.5, "rgba(255,255,255,0.2)");
        gradient.addColorStop(1, "rgba(0,0,0,0)");
        context.fillStyle = gradient;
        context.fillRect(0, 0, 32, 32);
        const texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;
        return texture;
      };

      const material = new THREE.PointsMaterial({
        size: PARTICLE_SIZE,
        map: getTexture(),
        transparent: true,
        opacity: 0.8,
        vertexColors: false,
        color: targetColor,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
      });

      const particles = new THREE.Points(geometry, material);
      scene.add(particles);

      // --- Shape Generators ---

      function getPointOnSphere() {
        const u = Math.random();
        const v = Math.random();
        const theta = 2 * Math.PI * u;
        const phi = Math.acos(2 * v - 1);
        const r = 2;
        return {
          x: r * Math.sin(phi) * Math.cos(theta),
          y: r * Math.sin(phi) * Math.sin(theta),
          z: r * Math.cos(phi),
        };
      }

      function getPointOnHeart() {
        // Heart surface approximation
        // Using a cloud of points inside a heart volume
        let x, y, z;
        // Rejection sampling or parametric
        const t = Math.random() * Math.PI * 2;
        const u = Math.random() * Math.PI;

        // 3D Heart formula variation
        // (x^2 + 9/4 y^2 + z^2 - 1)^3 - x^2z^3 - 9/80 y^2z^3 = 0
        // Simplified parametric approach for distribution

        // Let's use a simpler 2D extrusion or parametric eq
        // x = 16sin^3(t)
        // y = 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)
        // z = variation

        const r = Math.sqrt(Math.random()); // Distribution fix
        const t2 = Math.random() * Math.PI * 2;

        // Base 2D heart
        let hx = 16 * Math.pow(Math.sin(t2), 3);
        let hy = 13 * Math.cos(t2) - 5 * Math.cos(2 * t2) - 2 * Math.cos(3 * t2) - Math.cos(4 * t2);

        // Scale down
        hx *= 0.15;
        hy *= 0.15;

        // Add volume Z
        let hz = (Math.random() - 0.5) * 2;

        // Bulge z based on closeness to center to make it 3D-ish
        const dist = Math.sqrt(hx * hx + hy * hy);
        hz *= (1 - dist / 4) * 2;

        return { x: hx, y: hy, z: hz };
      }

      function getPointOnSaturn() {
        // 70% Planet, 30% Rings
        const isRing = Math.random() > 0.6;

        if (!isRing) {
          // Planet Sphere
          const u = Math.random();
          const v = Math.random();
          const theta = 2 * Math.PI * u;
          const phi = Math.acos(2 * v - 1);
          const r = 1.5;
          return {
            x: r * Math.sin(phi) * Math.cos(theta),
            y: r * Math.sin(phi) * Math.sin(theta),
            z: r * Math.cos(phi),
          };
        } else {
          // Rings
          const angle = Math.random() * Math.PI * 2;
          // Ring radius between 2.2 and 4
          const radius = 2.2 + Math.random() * 1.8;
          return {
            x: Math.cos(angle) * radius,
            y: (Math.random() - 0.5) * 0.1, // Flat y
            z: Math.sin(angle) * radius,
          };
        }
      }

      function getPointOnFlower() {
        // Rose curve in 3D
        const k = 4; // Petals
        const t = Math.random() * Math.PI * 2;
        const r = Math.cos(k * t) * 2 + 0.5; // +0.5 ensures center isn't empty
        const height = (Math.random() - 0.5) * 1;

        // Add curve to z based on radius to make it cup-like
        const zCurve = r * 0.5;

        return {
          x: r * Math.cos(t),
          y: height + zCurve * 0.5,
          z: r * Math.sin(t),
        };
      }

      function updateTargetShape(shape) {
        const positionsArr = new Float32Array(PARTICLE_COUNT * 3);

        for (let i = 0; i < PARTICLE_COUNT; i++) {
          let p;
          if (shape === "sphere") p = getPointOnSphere();
          else if (shape === "heart") p = getPointOnHeart();
          else if (shape === "saturn") p = getPointOnSaturn();
          else if (shape === "flower") p = getPointOnFlower();

          positionsArr[i * 3] = p.x;
          positionsArr[i * 3 + 1] = p.y;
          positionsArr[i * 3 + 2] = p.z;
        }
        return positionsArr;
      }

      // Generate all shapes once to save performance or generate on fly?
      // Generate on fly on switch is fine.
      let shapeTargets = {
        sphere: updateTargetShape("sphere"),
        heart: updateTargetShape("heart"),
        saturn: updateTargetShape("saturn"),
        flower: updateTargetShape("flower"),
      };

      // --- UI Interaction ---
      window.setShape = (shape) => {
        currentShape = shape;
        // Update UI
        document.querySelectorAll(".shape-btn").forEach((b) => b.classList.remove("active"));
        event.currentTarget.classList.add("active");

        // Trigger a little pop effect on particles
        // logic handled in animate loop via interpolation
      };

      window.setColor = (color) => {
        const c = new THREE.Color(color);
        // Tween logic for color
        const startColor = material.color.clone();

        // Simple manual tween
        let alpha = 0;
        const animateColor = () => {
          alpha += 0.05;
          if (alpha > 1) alpha = 1;
          material.color.lerpColors(startColor, c, alpha);
          if (alpha < 1) requestAnimationFrame(animateColor);
        };
        animateColor();

        // Update UI
        document.querySelectorAll(".color-swatch").forEach((b) => b.classList.remove("active"));
        if (event.currentTarget.classList.contains("color-swatch")) {
          event.currentTarget.classList.add("active");
        }
      };

      // --- MediaPipe Hands Setup ---
      const videoElement = document.getElementById("video-input");
      const canvasElement = document.getElementById("camera-feed");
      const canvasCtx = canvasElement.getContext("2d");

      function onResults(results) {
        // Hide loading screen once we have results
        const loadingScreen = document.getElementById("loading");
        if (loadingScreen && loadingScreen.style.opacity !== "0") {
          loadingScreen.style.opacity = "0";
          setTimeout(() => (loadingScreen.style.display = "none"), 500);
          document.getElementById("status-dot").classList.remove("bg-red-500");
          document.getElementById("status-dot").classList.add("bg-green-500");
          document.getElementById("status-text").innerText = "Tracking Active";
        }

        // Draw webcam feed to small canvas
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
          const landmarks = results.multiHandLandmarks[0];

          // Draw skeleton on preview
          drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, { color: "#00FF00", lineWidth: 1 });
          drawLandmarks(canvasCtx, landmarks, { color: "#FF0000", lineWidth: 1, radius: 2 });

          handState.present = true;

          // 1. Position (Rotation control)
          // Wrist is index 0, Middle finger MCP is 9. Average for center.
          const centerX = landmarks[9].x;
          const centerY = landmarks[9].y;

          // Smooth updates
          handState.x = lerp(handState.x, centerX, 0.2);
          handState.y = lerp(handState.y, centerY, 0.2);

          // 2. Pinch (Scaling)
          // Thumb Tip (4) to Index Tip (8)
          const thumbTip = landmarks[4];
          const indexTip = landmarks[8];
          const distance = Math.sqrt(Math.pow(thumbTip.x - indexTip.x, 2) + Math.pow(thumbTip.y - indexTip.y, 2));

          // Normalize pinch: < 0.05 is closed, > 0.1 is open
          // Map 0.02->0.15 to 0.5->2.0
          let rawScale = mapRange(distance, 0.02, 0.15, 0.5, 2.0);
          handState.pinchDistance = lerp(handState.pinchDistance, rawScale, 0.1);

          // 3. Hand Size / Distance (Spread/Explosion)
          // Wrist (0) to Middle Finger MCP (9) is a stable metric for distance
          const wrist = landmarks[0];
          const middleMCP = landmarks[9];
          const handLen = Math.sqrt(Math.pow(wrist.x - middleMCP.x, 2) + Math.pow(wrist.y - middleMCP.y, 2));

          // If hand is close (large length), spread is low (tight)
          // If hand is far (small length), spread is high (exploded)
          // Length usually varies 0.1 (far) to 0.4 (very close)
          handState.handSize = lerp(handState.handSize, handLen, 0.1);
        } else {
          handState.present = false;
          // Slowly return to default
          handState.pinchDistance = lerp(handState.pinchDistance, 1.0, 0.05);
          handState.x = lerp(handState.x, 0.5, 0.05);
          handState.y = lerp(handState.y, 0.5, 0.05);
        }
        canvasCtx.restore();
      }

      const hands = new Hands({
        locateFile: (file) => {
          return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        },
      });

      hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5,
      });

      hands.onResults(onResults);

      const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
          await hands.send({ image: videoElement });
        },
        width: 640,
        height: 480,
      });

      cameraUtils.start();

      // --- Animation Loop ---

      const clock = new THREE.Clock();

      // Helper Math
      function lerp(start, end, amt) {
        return (1 - amt) * start + amt * end;
      }
      function mapRange(value, inMin, inMax, outMin, outMax) {
        return ((value - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin;
      }

      function animate() {
        requestAnimationFrame(animate);
        const time = clock.getElapsedTime();

        // 1. Calculate Particle Dynamics based on Hand State

        // Rotation based on hand position (relative to center 0.5, 0.5)
        // Left (x<0.5) -> Rotate Left, Right -> Rotate Right
        const rotXSpeed = (handState.y - 0.5) * 2.0; // Up/Down controls X rotation
        const rotYSpeed = (handState.x - 0.5) * 2.0; // Left/Right controls Y rotation

        particles.rotation.x += rotXSpeed * 0.05;
        particles.rotation.y += rotYSpeed * 0.05;

        // Auto idle rotation if no hand
        if (!handState.present) {
          particles.rotation.y += 0.005;
        }

        // Scale based on Pinch
        // Default 1, pinched small
        const targetScale = handState.present ? handState.pinchDistance : 1.0;
        particles.scale.setScalar(lerp(particles.scale.x, targetScale, 0.1));

        // Spread / Explosion based on Distance (Hand Size)
        // Large hand (0.3) = Tight (spread 0)
        // Small hand (0.1) = Exploded (spread 1)
        let spreadFactor = 0;
        if (handState.present) {
          // Invert: Big hand = small spread
          spreadFactor = mapRange(handState.handSize, 0.1, 0.3, 3.0, 0.0);
          if (spreadFactor < 0) spreadFactor = 0;
        }

        // Update Particle Attributes
        const currentPos = particles.geometry.attributes.position.array;
        const targetPos = shapeTargets[currentShape];

        for (let i = 0; i < PARTICLE_COUNT; i++) {
          const i3 = i * 3;

          // Base target from shape
          const tx = targetPos[i3];
          const ty = targetPos[i3 + 1];
          const tz = targetPos[i3 + 2];

          // Add Explosion/Spread noise
          // We push the particle outward from center (0,0,0) based on spreadFactor
          // Use the normalized vector of the target position for direction
          // Or just random noise for "Chaos" effect requested
          // "Far = exploded/spread out. Make the exploded version random"

          // Random offset for explosion
          // We use a pseudo-random based on index to keep it deterministic per frame but chaotic looking
          const rx = (Math.random() - 0.5) * spreadFactor * 5;
          const ry = (Math.random() - 0.5) * spreadFactor * 5;
          const rz = (Math.random() - 0.5) * spreadFactor * 5;

          // But we want it to float back when spread reduces, not jitter like crazy.
          // So we calculate the "Exploded Target"
          // Let's use the index as a seed for stable random direction
          const seed = i * 0.123;
          const dirX = Math.sin(seed) * spreadFactor * 5;
          const dirY = Math.cos(seed * 1.5) * spreadFactor * 5;
          const dirZ = Math.sin(seed * 2.3) * spreadFactor * 5;

          const finalTx = tx + dirX;
          const finalTy = ty + dirY;
          const finalTz = tz + dirZ;

          // Lerp current to final target
          // Speed of Morph: 0.05
          currentPos[i3] += (finalTx - currentPos[i3]) * 0.08;
          currentPos[i3 + 1] += (finalTy - currentPos[i3 + 1]) * 0.08;
          currentPos[i3 + 2] += (finalTz - currentPos[i3 + 2]) * 0.08;
        }

        particles.geometry.attributes.position.needsUpdate = true;

        // Render
        renderer.render(scene, camera);
      }

      // Handle Resize
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      animate();
    </script>
  </body>
</html>
